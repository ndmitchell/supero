[STYLE]

Add back \balance in the bibtex

Fix up the page breaks

Check for lines running over columns


---------------------------------------------------------------------
-- CORE LANGUAGE

[THE SIMPLIFIER CAN INFINITE LOOP]

However, there is an example when such simplification goes into infinite loop. There is just a scheme of this loop - without handling let-bindings: 

data U = MkU (U -> Bool); 

(\u -> case u of {MkU p -> p u;}) (MkU (\x -> case x of {MkU y -> y x;})) => 
[by the 4th simplification rule] =>

case (MkU (\x -> case x of {MkU y -> y x;})) of 
{MkU p -> p (MkU (\x -> case x of {MkU y -> y x;}));} =>
[by the 5th simplification rule] =?
(\u -> case u of {MkU p -> p u;}) (MkU (\x -> case x of {MkU y -> y x;})) 
and we are in the loop now. 

So this expression is not in simplified form. Since further sections are based on simplified core, this problem should be resolved in some way. For example, it is possible to extract some lambda abstractions into global functions. 

The non-termination issue was also spotted (after the submission of my paper) by Ilya Klyuchnikov, who has written a paper "Supercompiler HOSC 1.1: proof of termination". His paper discusses the non-termination problem, and I will include a citation. The non-termination is a corner case (unlikely to occur in real programs), but should be possible to fix with a small change to the simplifier. Thank you for finding this example.


---------------------------------------------------------------------
-- RELATED WORK


The description of partial evaluation in Section 5.2 tells only half the
story. What is said there about binding time analysis and subsequent
specialization based on the markings is specific only to *offline*
partial evaluation. But there is *online* partial evaluation as well,
which works differently, and is actually much closer to the kind of
compile-time computations that happen in supercompilation. So a
comparison to online partial evaluation would be more meaningful.

I also find the description of deforestation techniques in Section 5.3 a
bit sloppy, and the citations rather arbitrary. First of all, it would
make more sense to cite Wadler's 1990 paper in TCS, rather than the
preceding conference version. Also, it is then said that his technique
was extended in many ways, among others to work on other data types than
lists. But already Wadler's original technique works for arbitrary
datatypes! After all, the title is "Transforming programs to eliminate
*trees*". Moreover, the citation of Coutts et al. 2007b is rather
strange in this context. Their technique has nothing to do with
Wadler-style deforestation. If anything, it would be an example for
combinator/rules-based optimizations as described in the subsequent
paragraph. In that paragraph, it is implied that shortcut fusion and
related techniques are restricted to lists. But again, these have
straightforward extensions to arbitrary datatypes (see "A Generalization
of Short-Cut Fusion and its Correctness Proof", Johann, HOSC 2002).

There is a large literature on termination orderings which goes almost
entirely uncited. Is there a reason for this?
